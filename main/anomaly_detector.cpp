/**
 * @file anomaly_detector.cpp
 * @brief Main Integration - Sensor + DSP + AI Anomaly Detection
 * 
 * This is the main application that integrates:
 * 1. INMP441 I2S Microphone capture
 * 2. Real-time STFT spectrogram generation
 * 3. TFLite Micro autoencoder inference
 * 4. Anomaly detection via reconstruction error
 * 
 * Hardware Setup:
 * - ESP32 DevKit
 * - INMP441 I2S Microphone (BCK=33, WS=25, SD=32)
 * - LED on GPIO2 for anomaly indication
 * - MPU6050 for wake-on-motion (optional, from Task 1)
 */

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"

#include "esp_log.h"
#include "esp_err.h"
#include "esp_heap_caps.h"
#include "driver/gpio.h"

// Project headers
#include "i2s_microphone.hpp"
#include "stft_processor.hpp"
#include "tflite_inference.hpp"

// Include the embedded TFLite model
// This is generated by the Python script
#include "model_data.h"

static const char* TAG = "AnomalyDetector";

// =============================================================================
// CONFIGURATION
// =============================================================================

namespace config {

    // GPIO Configuration
    constexpr gpio_num_t LED_ANOMALY_PIN = GPIO_NUM_2;     // Built-in LED
    constexpr gpio_num_t LED_STATUS_PIN = GPIO_NUM_4;       // Optional status LED
    
    // I2S Microphone Pins (INMP441)
    constexpr gpio_num_t I2S_BCK_PIN = GPIO_NUM_33;
    constexpr gpio_num_t I2S_WS_PIN = GPIO_NUM_25;
    constexpr gpio_num_t I2S_DATA_PIN = GPIO_NUM_32;
    
    // Audio Configuration
    constexpr uint32_t SAMPLE_RATE = 16000;                 // 16 kHz
    constexpr size_t AUDIO_BUFFER_SIZE = 8192;              // Samples in audio buffer
    
    // STFT Configuration
    constexpr size_t FFT_SIZE = 512;                         // 32ms window @ 16kHz
    constexpr size_t HOP_SIZE = 128;                         // 8ms hop (75% overlap)
    constexpr size_t NUM_FRAMES = 32;                        // 32 time frames
    constexpr size_t NUM_FREQ_BINS = FFT_SIZE / 2;           // 256 bins (we use 32)
    
    // Spectrogram dimensions for NN (must match model)
    constexpr size_t SPEC_HEIGHT = 32;                       // Frequency bins for model
    constexpr size_t SPEC_WIDTH = 32;                        // Time frames for model
    
    // TFLite Configuration
    constexpr size_t TENSOR_ARENA_SIZE = 80 * 1024;         // 80KB tensor arena
    constexpr float ANOMALY_THRESHOLD = 0.035f;              // Tune based on training
    
    // Detection Loop Configuration
    // Interval must be > inference time (~700ms) + margin for IDLE task
    constexpr uint32_t DETECTION_INTERVAL_MS = 1500;          // Run detection every 1.5s
    constexpr uint32_t ANOMALY_LED_DURATION_MS = 2000;       // LED on duration after anomaly
    constexpr uint32_t IDLE_YIELD_MS = 100;                  // Yield time for watchdog
    
    // Memory Configuration
    constexpr size_t MAIN_TASK_STACK_SIZE = 8192;            // Main task stack size

} // namespace config

// =============================================================================
// GLOBAL STATE
// =============================================================================

// Allocated on heap to avoid stack overflow
static float* g_audio_buffer = nullptr;           // Raw audio samples
static float* g_spectrogram = nullptr;            // STFT output
static float* g_nn_input = nullptr;               // Resized spectrogram for NN

// State
static bool g_anomaly_detected = false;
static TickType_t g_anomaly_time = 0;
static uint32_t g_detection_count = 0;
static uint32_t g_anomaly_count = 0;

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/**
 * @brief Initialize GPIO for LED indicators
 */
static esp_err_t initGPIO() {
    gpio_config_t io_conf = {};
    io_conf.intr_type = GPIO_INTR_DISABLE;
    io_conf.mode = GPIO_MODE_OUTPUT;
    io_conf.pin_bit_mask = (1ULL << config::LED_ANOMALY_PIN);
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
    
    esp_err_t ret = gpio_config(&io_conf);
    if (ret == ESP_OK) {
        gpio_set_level(config::LED_ANOMALY_PIN, 0);
    }
    
    return ret;
}

/**
 * @brief Set anomaly LED state
 */
static void setAnomalyLED(bool on) {
    gpio_set_level(config::LED_ANOMALY_PIN, on ? 1 : 0);
}

/**
 * @brief Allocate large buffers on heap
 */
static esp_err_t allocateBuffers() {
    size_t audio_bytes = config::AUDIO_BUFFER_SIZE * sizeof(float);
    size_t spec_bytes = config::NUM_FREQ_BINS * config::NUM_FRAMES * sizeof(float);
    size_t nn_bytes = config::SPEC_HEIGHT * config::SPEC_WIDTH * sizeof(float);
    
    ESP_LOGI(TAG, "Allocating buffers:");
    ESP_LOGI(TAG, "  Audio buffer: %d bytes", audio_bytes);
    ESP_LOGI(TAG, "  Spectrogram: %d bytes", spec_bytes);
    ESP_LOGI(TAG, "  NN input: %d bytes", nn_bytes);
    
    // Try PSRAM first, fall back to internal RAM
    g_audio_buffer = static_cast<float*>(
        heap_caps_malloc(audio_bytes, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT));
    if (!g_audio_buffer) {
        g_audio_buffer = static_cast<float*>(
            heap_caps_malloc(audio_bytes, MALLOC_CAP_8BIT));
    }
    
    g_spectrogram = static_cast<float*>(
        heap_caps_malloc(spec_bytes, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT));
    if (!g_spectrogram) {
        g_spectrogram = static_cast<float*>(
            heap_caps_malloc(spec_bytes, MALLOC_CAP_8BIT));
    }
    
    g_nn_input = static_cast<float*>(
        heap_caps_malloc(nn_bytes, MALLOC_CAP_8BIT));
    
    if (!g_audio_buffer || !g_spectrogram || !g_nn_input) {
        ESP_LOGE(TAG, "Failed to allocate buffers!");
        return ESP_ERR_NO_MEM;
    }
    
    // Log heap status
    ESP_LOGI(TAG, "Free heap: %d bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "Free PSRAM: %d bytes", heap_caps_get_free_size(MALLOC_CAP_SPIRAM));
    
    return ESP_OK;
}

/**
 * @brief Resize spectrogram to match NN input dimensions
 * 
 * The STFT produces (256 freq bins x 32 frames), but our NN expects (32 x 32).
 * We take the lower 32 frequency bins which contain motor frequencies.
 */
static void resizeSpectrogramForNN(const float* full_spec, float* nn_spec) {
    // Take first 32 frequency bins (0-1000 Hz at 16kHz sample rate)
    // Each time frame already has NUM_FREQ_BINS values
    
    for (size_t frame = 0; frame < config::SPEC_WIDTH; frame++) {
        for (size_t freq = 0; freq < config::SPEC_HEIGHT; freq++) {
            // Map frequency bins - take every 8th bin to sample across range
            // Or simply take first 32 bins for low-frequency content
            size_t src_freq = freq;  // Take first 32 bins (low frequencies)
            
            size_t src_idx = frame * config::NUM_FREQ_BINS + src_freq;
            size_t dst_idx = frame * config::SPEC_HEIGHT + freq;
            
            nn_spec[dst_idx] = full_spec[src_idx];
        }
    }
}

/**
 * @brief Print detection statistics
 */
static void printStats() {
    float anomaly_rate = (g_detection_count > 0) ? 
        (100.0f * g_anomaly_count / g_detection_count) : 0;
    
    ESP_LOGI(TAG, "Statistics: %d detections, %d anomalies (%.1f%%)",
             g_detection_count, g_anomaly_count, anomaly_rate);
}

// =============================================================================
// MAIN DETECTION LOOP
// =============================================================================

/**
 * @brief Main anomaly detection task
 */
static void anomalyDetectionTask(void* pvParameters) {
    ESP_LOGI(TAG, "Starting anomaly detection task");
    
    // Initialize components
    
    // 1. I2S Microphone
    pdm::I2SMicConfig mic_config = {
        .bck_pin = config::I2S_BCK_PIN,
        .ws_pin = config::I2S_WS_PIN,
        .data_pin = config::I2S_DATA_PIN,
        .sample_rate = config::SAMPLE_RATE,
        .dma_buffer_count = 8,
        .dma_buffer_size = 1024,
        .i2s_port = I2S_NUM_0
    };
    
    pdm::I2SMicrophone microphone(mic_config);
    if (microphone.init() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize microphone");
        vTaskDelete(nullptr);
        return;
    }
    
    // 2. STFT Processor
    pdm::STFTConfig stft_config = {
        .fft_size = config::FFT_SIZE,
        .hop_size = config::HOP_SIZE,
        .num_frames = config::NUM_FRAMES,
        .sample_rate = config::SAMPLE_RATE
    };
    
    pdm::STFTProcessor stft(stft_config);
    if (stft.init() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize STFT processor");
        vTaskDelete(nullptr);
        return;
    }
    
    // 3. TFLite Inference
    pdm::InferenceConfig inference_config = {
        .tensor_arena_size = config::TENSOR_ARENA_SIZE,
        .anomaly_threshold = config::ANOMALY_THRESHOLD,
        .input_height = config::SPEC_HEIGHT,
        .input_width = config::SPEC_WIDTH
    };
    
    pdm::TFLiteInference inference(model_data, model_data_len, inference_config);
    if (inference.init() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize TFLite inference");
        vTaskDelete(nullptr);
        return;
    }
    
    // Start microphone capture
    if (microphone.start() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start microphone");
        vTaskDelete(nullptr);
        return;
    }
    
    ESP_LOGI(TAG, "All components initialized - starting detection loop");
    ESP_LOGI(TAG, "Detection interval: %d ms, Threshold: %.4f",
             config::DETECTION_INTERVAL_MS, config::ANOMALY_THRESHOLD);
    ESP_LOGW(TAG, "Note: Task watchdog warnings are expected due to long inference time");
    
    size_t required_samples = stft.getRequiredSamples();
    ESP_LOGI(TAG, "Required samples per detection: %d (%.1f ms)",
             required_samples, 1000.0f * required_samples / config::SAMPLE_RATE);
    
    // Main detection loop
    while (true) {
        uint32_t loop_start = xTaskGetTickCount();
        
        // ====== STEP 1: Capture Audio ======
        size_t samples_read = microphone.readFloat(g_audio_buffer, required_samples, 2000);
        
        if (samples_read < required_samples) {
            ESP_LOGW(TAG, "Insufficient samples: %d/%d", samples_read, required_samples);
            vTaskDelay(pdMS_TO_TICKS(100));
            continue;
        }
        
        // ====== STEP 2: Compute STFT Spectrogram ======
        TickType_t stft_start = xTaskGetTickCount();
        
        esp_err_t ret = stft.process(g_audio_buffer, samples_read, g_spectrogram);
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "STFT processing failed");
            continue;
        }
        
        // Normalize spectrogram to [0, 1]
        stft.normalizeSpectrogram(g_spectrogram, stft.getSpectrogramSize());
        
        uint32_t stft_time_ms = (xTaskGetTickCount() - stft_start) * portTICK_PERIOD_MS;
        
        // ====== STEP 3: Resize for Neural Network ======
        resizeSpectrogramForNN(g_spectrogram, g_nn_input);
        
        // ====== STEP 4: Run TFLite Inference ======
        pdm::InferenceResult result;
        ret = inference.runInference(g_nn_input, result);
        
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Inference failed");
            continue;
        }
        
        // ====== STEP 5: Decision - Anomaly Detection ======
        g_detection_count++;
        
        if (result.is_anomaly) {
            g_anomaly_count++;
            g_anomaly_detected = true;
            g_anomaly_time = xTaskGetTickCount();
            
            ESP_LOGW(TAG, "ðŸš¨ ANOMALY DETECTED! MSE=%.4f (threshold=%.4f)",
                     result.reconstruction_error, config::ANOMALY_THRESHOLD);
            
            // Turn on LED
            setAnomalyLED(true);
        } else {
            // Check if LED should be turned off
            if (g_anomaly_detected) {
                uint32_t elapsed_ms = (xTaskGetTickCount() - g_anomaly_time) * portTICK_PERIOD_MS;
                if (elapsed_ms > config::ANOMALY_LED_DURATION_MS) {
                    setAnomalyLED(false);
                    g_anomaly_detected = false;
                }
            }
            
            ESP_LOGI(TAG, "âœ“ Normal: MSE=%.4f, inference=%dms",
                     result.reconstruction_error, result.inference_time_ms);
        }
        
        // Print stats every 20 detections
        if (g_detection_count % 20 == 0) {
            printStats();
            ESP_LOGI(TAG, "STFT time: %lu ms, Inference time: %d ms",
                     stft_time_ms, result.inference_time_ms);
        }
        
        // Maintain detection interval and yield to IDLE task for watchdog
        vTaskDelay(pdMS_TO_TICKS(config::IDLE_YIELD_MS));  // Let IDLE run for watchdog
        
        uint32_t elapsed_ms = (xTaskGetTickCount() - loop_start) * portTICK_PERIOD_MS;
        if (elapsed_ms < config::DETECTION_INTERVAL_MS) {
            vTaskDelay(pdMS_TO_TICKS(config::DETECTION_INTERVAL_MS - elapsed_ms));
        }
    }
}

// =============================================================================
// APP MAIN
// =============================================================================

extern "C" void app_main(void) {
    ESP_LOGI(TAG, "========================================");
    ESP_LOGI(TAG, "  Predictive Maintenance - Anomaly Detector");
    ESP_LOGI(TAG, "  Audio-based Fault Detection with TinyML");
    ESP_LOGI(TAG, "========================================");
    
    // Print memory info
    ESP_LOGI(TAG, "Free heap at start: %d bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "Free PSRAM: %d bytes", heap_caps_get_free_size(MALLOC_CAP_SPIRAM));
    
    // Initialize GPIO
    if (initGPIO() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize GPIO");
        return;
    }
    
    // Blink LED to indicate startup
    for (int i = 0; i < 3; i++) {
        setAnomalyLED(true);
        vTaskDelay(pdMS_TO_TICKS(100));
        setAnomalyLED(false);
        vTaskDelay(pdMS_TO_TICKS(100));
    }
    
    // Allocate buffers
    if (allocateBuffers() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to allocate buffers - not enough memory!");
        return;
    }
    
    // Create detection task with large stack
    BaseType_t ret = xTaskCreatePinnedToCore(
        anomalyDetectionTask,
        "anomaly_detect",
        config::MAIN_TASK_STACK_SIZE,
        nullptr,
        5,  // Priority
        nullptr,
        1   // Run on Core 1 (Core 0 handles WiFi/BT if used)
    );
    
    if (ret != pdPASS) {
        ESP_LOGE(TAG, "Failed to create detection task");
        return;
    }
    
    ESP_LOGI(TAG, "Anomaly detection task started");
    
    // Main task can enter idle or handle other functions
    while (true) {
        vTaskDelay(pdMS_TO_TICKS(10000));
        ESP_LOGI(TAG, "System running... Free heap: %d bytes", esp_get_free_heap_size());
    }
}
